import type { EthereumProvider } from "hardhat/types/providers";
import type { CompilerOutputBytecode } from "hardhat/types/solidity";
interface ByteOffset {
    start: number;
    length: number;
}
export declare class Bytecode {
    #private;
    readonly bytecode: string;
    readonly solcVersion: string;
    readonly executableSection: string;
    private constructor();
    static getDeployedContractBytecode(provider: EthereumProvider, address: string, networkName: string): Promise<Bytecode>;
    hasVersionRange(): boolean;
    /**
     * Compares the executable sections of the deployed and compiled bytecode,
     * ignoring differences in metadata, library link references, immutable
     * variables, and call protection placeholders.
     *
     * This is necessary because deployed bytecode contains dynamically inserted
     * values (e.g. actual library addresses), while the compiler output contains
     * placeholders. To make the comparison meaningful, both bytecode strings are
     * normalized before comparison.
     *
     * See: https://ethereum.org/en/developers/docs/smart-contracts/verifying/#etherscan
     *
     * @param compilerOutputBytecode The `evm.deployedBytecode` section of a
     * compiled contract.
     * @returns `true` if the normalized deployed and compiled bytecode are
     * equivalent, `false` otherwise.
     */
    compare(compilerOutputBytecode: CompilerOutputBytecode): boolean;
}
/**
 * Extracts the executable portion of a contract's bytecode without
 * decoding it.
 *
 * Solidity appends metadata to the end of the bytecode. This metadata
 * includes a two-byte field indicating its total length. This function
 * removes that metadata segment and returns only the executable code.
 *
 * This approach avoids decoding issues that can occur if the bytecode
 * includes linker placeholders or non-hex characters.
 *
 * @param bytecode The full contract bytecode as a hex string
 * (with or without `0x` prefix).
 * @returns The hex string of the executable code, excluding metadata.
 */
export declare function inferExecutableSection(bytecode: string): string;
/**
 * Replaces all known dynamic offset segments in the bytecode with zeros.
 *
 * These segments include:
 * - Library link references (placeholders for external addresses).
 * - Immutable variable references (set during deployment).
 * - Call protection patterns (used for things like delegatecall guards).
 *
 * This is useful for comparing or analyzing bytecode in a normalized form,
 * ignoring dynamic values.
 *
 * @param bytecode The bytecode executable section as a hex string (without
 * `0x` prefix).
 * @param compilerOutputBytecode The reference compiler output containing
 * known offset positions.
 * @returns The bytecode string with all known dynamic offsets zeroed out.
 */
export declare function nullifyBytecodeOffsets(bytecode: string, { object: unlinkedBytecode, linkReferences, immutableReferences, }: CompilerOutputBytecode): string;
/**
 * Extracts all bytecode offsets where libraries are expected to be linked.
 *
 * Solidity organizes link references as a nested object:
 * `{ sourceFile: { libraryName: [{ start, length }, ...] } }`.
 * This function flattens that structure and returns a single list
 * of offsets where linking placeholders are present.
 *
 * @param linkReferences The link references object from compiler output.
 * @returns An array of byte offsets for all library link placeholders.
 */
export declare function getLibraryOffsets(linkReferences?: CompilerOutputBytecode["linkReferences"]): ByteOffset[];
/**
 * Extracts all bytecode offsets where immutable variables are used.
 *
 * Immutable variables are inserted into the bytecode at deployment time,
 * and the compiler emits their positions in `immutableReferences`.
 *
 * @param immutableReferences Immutable references from compiler output.
 * @returns An array of byte offsets where immutable values will be written.
 */
export declare function getImmutableOffsets(immutableReferences?: CompilerOutputBytecode["immutableReferences"]): ByteOffset[];
/**
 * Detects and returns the offset of the call protection pattern in a library
 * bytecode.
 *
 * Solidity libraries include a call protection mechanism that starts the
 * bytecode with `PUSH20 <address>`, a placeholder address (usually all
 * zeros) that prevents direct usage.
 *
 * This function checks if the `referenceBytecode` starts with such a
 * placeholder and, if the actual `bytecode` starts with a real `PUSH20`,
 * returns the offset where the address starts (always 1).
 *
 * @param bytecode The bytecode of the contract as a hex string (without
 * `0x` prefix).
 * @param unlinkedBytecode The compiler output bytecode as a hex string
 * (without `0x` prefix).
 * @returns An array with a single offset entry if call protection is detected,
 * or an empty array otherwise.
 */
export declare function getCallProtectionOffsets(bytecode: string, unlinkedBytecode: string): ByteOffset[];
export {};
//# sourceMappingURL=bytecode.d.ts.map