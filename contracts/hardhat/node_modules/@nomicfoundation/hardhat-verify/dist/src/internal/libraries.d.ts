import type { ContractInformation } from "./contract.js";
export interface LibraryInformation {
    libraries: SourceLibraries;
    undetectableLibraries: string[];
}
export type SourceLibraries = Record<string, LibraryAddresses>;
export type LibraryAddresses = Record<string, string>;
/**
 * Resolves all required library information for contract verification.
 *
 * Processes the link references from the contract's creation bytecode and the
 * deployed bytecode to determine which libraries are used, which can be
 * detected automatically, and which must be provided by the user. It merges
 * user-specified library addresses with those detected from the bytecode,
 * ensuring there are no conflicts or duplicates.
 *
 * @param contractInformation Information about the contract, including
 * compiler output and deployed bytecode.
 * @param userLibraryAddresses Mapping of user-specified library names (short
 * or FQN) to addresses.
 * @returns An object containing all resolved library addresses and the list of
 * undetectable libraries.
 *   - libraries: Mapping of source names to library names to addresses.
 *   - undetectableLibraries: Array of library FQNs that cannot be detected
 * automatically.
 * @throws {HardhatError} with the descriptor:
 *   - INVALID_LIBRARY_ADDRESS if a user-provided library address is invalid.
 *   - DUPLICATED_LIBRARY if the same library is specified more than once
 * (by name or FQN).
 *   - UNUSED_LIBRARY if a specified library is not used by the contract.
 *   - LIBRARY_MULTIPLE_MATCHES if a provided library name is ambiguous
 * (matches multiple libraries).
 *   - LIBRARY_ADDRESSES_MISMATCH if a library address provided by the user
 * conflicts with an address detected from the bytecode.
 *   - MISSING_LIBRARY_ADDRESSES if any required library addresses are
 * missing.
 */
export declare function resolveLibraryInformation(contractInformation: ContractInformation, userLibraryAddresses: LibraryAddresses): LibraryInformation;
/**
 * Returns a list of fully qualified library names in the format `source:library`.
 *
 * @param libraries Nested mapping from source name to library names.
 * @returns An array of fully qualified names (e.g., "contracts/Lib.sol:MyLib").
 */
export declare function getLibraryFqns(libraries: Record<string, Record<string, unknown>>): string[];
/**
 * Resolves and validates user-specified libraries for contract verification.
 *
 * Matches each user-provided library name or FQN to the contract's required
 * libraries, ensures the address is valid, checks for ambiguity, and prevents
 * duplicates.
 *
 * @param allLibraryFqns All fully qualified library names (`source:library`)
 * used by the contract, derived from the keys in the `linkReferences`
 * mapping of the contract’s creation bytecode. Includes both detectable and
 * undetectable libraries.
 * @param detectableLibraryFqns Fully qualified library names present in the
 * `linkReferences` mapping of the deployed bytecode. These libraries can be
 * detected automatically and do not require user-specified addresses.
 * @param undetectableLibraryFqns Fully qualified library names found in the
 * creation bytecode’s `linkReferences` but not in the deployed bytecode’s
 * `linkReferences`. These must be specified by the user.
 * @param userLibraryAddresses User-provided mapping from library name (short
 * or FQN) to address.
 * @param contract Fully qualified name of the contract.
 * @returns A mapping of source names to library names to addresses.
 * @throws {HardhatError} with the descriptor:
 *   - INVALID_LIBRARY_ADDRESS if a user-provided library address is invalid.
 *   - DUPLICATED_LIBRARY if the same library is specified more than once
 * (by name or FQN).
 *   - UNUSED_LIBRARY if a specified library is not used by the contract.
 *   - LIBRARY_MULTIPLE_MATCHES if a provided library name is ambiguous
 * (matches multiple libraries).
 */
export declare function resolveUserLibraries(allLibraryFqns: string[], detectableLibraryFqns: string[], undetectableLibraryFqns: string[], userLibraryAddresses: LibraryAddresses, contract: string): SourceLibraries;
/**
 * Searches for a library by its name or fully qualified name in the array of
 * all libraries. Throws an error if the library is not found or if multiple
 * libraries match the name.
 */
export declare function lookupLibrary(allLibraryFqns: string[], detectableLibraryFqns: string[], undetectableLibraryFqns: string[], libraryName: string, contract: string): string;
/**
 * Extracts linked library addresses from deployed bytecode using link
 * references. Assumes all offsets for a given library will have the same
 * address and only reads the first occurrence.
 */
export declare function getDetectableLibrariesFromBytecode(linkReferences: {
    [sourceName: string]: {
        [libraryName: string]: Array<{
            start: number;
            length: 20;
        }>;
    };
} | undefined, deployedBytecode: string): SourceLibraries;
/**
 * Merges user-specified and detected library addresses, ensuring there are no
 * conflicts. Throws if a library address is provided by the user and also
 * detected, but the addresses do not match.
 */
export declare function mergeLibraries(userLibraries: SourceLibraries, detectedLibraries: SourceLibraries): SourceLibraries;
//# sourceMappingURL=libraries.d.ts.map